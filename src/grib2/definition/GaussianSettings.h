// ***********************************************************************
//                      DO NOT EDIT THIS FILE !!!
// ***********************************************************************
//   This file is automatically generated from the grib_api templates. All
//   changes will be overridden. If you want to do permanent changes then
//   you should write them into the 'GaussianSettingsImpl.*' files.
// ***********************************************************************

#pragma once
#include "../../common/AttributeList.h"
#include "../../common/DataWriter.h"
#include "../../common/MemoryReader.h"
#include "../../grid/Typedefs.h"
#include "GridSettings.h"
#include "ScanningModeSettings.h"

namespace SmartMet {
namespace GRIB2 {
/*! \brief The class is automatically created from the template (3.gaussian).*/

class GaussianSettings {
public:
  GaussianSettings();
  virtual ~GaussianSettings();

  virtual void read(MemoryReader &memoryReader);
  virtual void write(DataWriter &dataWriter);
  virtual void getAttributeList(const std::string &prefix, T::AttributeList &attributeList) const;
  virtual bool getAttributeValue(const char *attributeName, std::string &attributeValue) const;
  virtual bool hasAttributeValue(const char *attributeName, const char *attributeValue) const;
  virtual void print(std::ostream &stream, uint level, uint optionFlags) const;
  virtual T::Hash countHash() const;

  GridSettings *getGrid() const;
  void setGrid(GridSettings &grid);
  const T::UInt32_opt &getIDirectionIncrement() const;
  void setIDirectionIncrement(T::UInt32_opt iDirectionIncrement);
  const T::UInt32_opt &getN() const;
  void setN(T::UInt32_opt n);
  ScanningModeSettings *getScanningMode() const;
  void setScanningMode(ScanningModeSettings &scanningMode);

protected:
  // # Copyright 2005-2019 ECMWF.
  //
  // include "grib2/template.3.grid.def";

  mutable GridSettings mGrid;

  //
  // #  Di - i direction increment
  // unsigned[4] iDirectionIncrement : can_be_missing;

  T::UInt32_opt mIDirectionIncrement;

  // alias Di = iDirectionIncrement;
  //
  // #  N - number of parallels between a pole and the equator
  // unsigned[4] N  : dump;

  T::UInt32_opt mN;

  // alias numberOfParallelsBetweenAPoleAndTheEquator=N ;
  // alias geography.N=N;
  //
  // include "grib2/template.3.scanning_mode.def";

  mutable ScanningModeSettings mScanningMode;

  //
  // modify Ni : can_be_missing,dump;
  //
  // meta g2grid g2grid(
  //     latitudeOfFirstGridPoint,
  //     longitudeOfFirstGridPoint,
  //     latitudeOfLastGridPoint,
  //     longitudeOfLastGridPoint,
  //     iDirectionIncrement,
  //     null,
  //     basicAngleOfTheInitialProductionDomain,
  //     subdivisionsOfBasicAngle
  //     );
  //
  // meta      geography.latitudeOfFirstGridPointInDegrees    g2latlon(g2grid,0) : dump;
  // meta      geography.longitudeOfFirstGridPointInDegrees   g2latlon(g2grid,1) : dump;
  // meta      geography.latitudeOfLastGridPointInDegrees     g2latlon(g2grid,2) : dump;
  // meta      geography.longitudeOfLastGridPointInDegrees    g2latlon(g2grid,3) : dump;
  // meta      geography.iDirectionIncrementInDegrees         g2latlon(g2grid,4,iDirectionIncrementGiven) : can_be_missing,dump;
  //
  // meta global global_gaussian(N,Ni,iDirectionIncrement,
  //                             latitudeOfFirstGridPoint,
  //                             longitudeOfFirstGridPoint,
  //                             latitudeOfLastGridPoint,
  //                             longitudeOfLastGridPoint,
  //                             PLPresent, pl,
  //                             basicAngleOfTheInitialProductionDomain,
  //                             subdivisionsOfBasicAngle) = 0 : dump;
  //
  // alias xFirst=longitudeOfFirstGridPointInDegrees;
  // alias yFirst=latitudeOfFirstGridPointInDegrees;
  // alias xLast=longitudeOfLastGridPointInDegrees;
  // alias yLast=latitudeOfLastGridPointInDegrees;
  //
  // alias latitudeFirstInDegrees  = latitudeOfFirstGridPointInDegrees;
  // alias longitudeFirstInDegrees = longitudeOfFirstGridPointInDegrees;
  // alias latitudeLastInDegrees   = latitudeOfLastGridPointInDegrees;
  // alias longitudeLastInDegrees  = longitudeOfLastGridPointInDegrees;
  // alias DiInDegrees             = iDirectionIncrementInDegrees;
  //
  // if(missing(Ni) && PLPresent == 1){
  //   iterator gaussian_reduced(numberOfPoints,missingValue,values,
  //     latitudeOfFirstGridPointInDegrees,longitudeOfFirstGridPointInDegrees,
  //     latitudeOfLastGridPointInDegrees,longitudeOfLastGridPointInDegrees,
  //       N,pl,Nj);
  //   nearest reduced(values,radius,Nj,pl);
  //
  //   #meta sumPlArray sum(pl);
  //   #meta dataGlobal evaluate( sumPlArray == (numberOfValues+numberOfMissing) );
  // } else {
  //     iterator gaussian(numberOfPoints,missingValue,values,
  //               longitudeFirstInDegrees,DiInDegrees  ,
  //               Ni,Nj,iScansNegatively,
  //               latitudeFirstInDegrees, latitudeLastInDegrees,
  //               N,jScansPositively);
  //     nearest regular(values,radius,Ni,Nj);
  // }
  // meta latLonValues latlonvalues(values);
  // alias latitudeLongitudeValues=latLonValues;
  // meta latitudes latitudes(values,0);
  // meta longitudes longitudes(values,0);
  // meta distinctLatitudes latitudes(values,1);
  // meta distinctLongitudes longitudes(values,1);
  //
  // meta isOctahedral octahedral_gaussian(N, Ni, PLPresent, pl) = 0 : no_copy,dump;
  //
  // meta gaussianGridName gaussian_grid_name(N, Ni, isOctahedral);
  // alias gridName=gaussianGridName;
  //
  //
  // # For sub-areas
  // # Uses new algorithm for counting. No support for legacy mode
  // meta numberOfDataPointsExpected number_of_points_gaussian(Ni,Nj,PLPresent,pl,N,
  //   latitudeOfFirstGridPointInDegrees,longitudeOfFirstGridPointInDegrees,
  //   latitudeOfLastGridPointInDegrees,longitudeOfLastGridPointInDegrees,zero) : dump;
  //
  // meta legacyGaussSubarea evaluate(numberOfDataPoints != numberOfDataPointsExpected);
};

} // namespace GRIB2
} // namespace SmartMet
